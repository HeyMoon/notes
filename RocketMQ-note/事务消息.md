RocketMQ事务消息是发生在Producer和Broker之间，是二阶段提交。

事务消息实现分析：

````
public TransactionSendResult sendMessageInTransaction(final Message msg, final LocalTransactionExecuter tranExecuter, final Object arg)
            throws MQClientException {
        if (null == tranExecuter) {
            throw new MQClientException("tranExecutor is null", null);
        }
        Validators.checkMessage(msg, this.defaultMQProducer);

        SendResult sendResult = null;
        //1. 发送一条TransactionPreparedType类型消息
        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, "true");
        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());
        try {
          //2. 发送至Broker
            sendResult = this.send(msg);
        } catch (Exception e) {
            throw new MQClientException("send message Exception", e);
        }

        LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;
        Throwable localException = null;
        switch (sendResult.getSendStatus()) {
            case SEND_OK: {
                try {
                    if (sendResult.getTransactionId() != null) {
                        msg.putUserProperty("__transactionId__", sendResult.getTransactionId());
                    }
                    // 3.执行本地操作，返回本地事务状态
                    localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg);
                    if (null == localTransactionState) {
                        localTransactionState = LocalTransactionState.UNKNOW;
                    }

                    if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {
                        log.info("executeLocalTransactionBranch return {}", localTransactionState);
                        log.info(msg.toString());
                    }
                } catch (Throwable e) {
                    log.info("executeLocalTransactionBranch exception", e);
                    log.info(msg.toString());
                    localException = e;
                }
            }
            break;
            case FLUSH_DISK_TIMEOUT:
            case FLUSH_SLAVE_TIMEOUT:
            case SLAVE_NOT_AVAILABLE:
                localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;
                break;
            default:
                break;
        }

        try {
            this.endTransaction(sendResult, localTransactionState, localException);
        } catch (Exception e) {
            log.warn("local transaction execute " + localTransactionState + ", but end broker transaction failed", e);
        }

        TransactionSendResult transactionSendResult = new TransactionSendResult();
        transactionSendResult.setSendStatus(sendResult.getSendStatus());
        transactionSendResult.setMessageQueue(sendResult.getMessageQueue());
        transactionSendResult.setMsgId(sendResult.getMsgId());
        transactionSendResult.setQueueOffset(sendResult.getQueueOffset());
        transactionSendResult.setTransactionId(sendResult.getTransactionId());
        transactionSendResult.setLocalTransactionState(localTransactionState);
        return transactionSendResult;
    }
````    

1. TransactionMQProducer向Broker发送一条类型为TransactionPreparedType，`MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, "true");`

2. Broker接收消息保存在CommitLog中，然后返回消息的queueOffset，offsetMsgId以及事务Id`transactionId`到Producer，offsetMsgId包含有commitLogOffset（即消息在CommitLog中的偏移量），由于该类型的消息不会保存到consumerQueue中，所以客户端通过consumerQueue取不到commitLogOffset，所以该类型的消息无法被取到，导致不会被消费。`sendResult = this.send(msg);`

3. 如果Broker返回SEND_OK,Producer端的LocalTransactionExecuter执行本地操作，返回本地事务状态，如上面代码`localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg);`所示。

4. 调用`this.endTransaction(sendResult, localTransactionState, localException);`结束事务。

   (1)如果本地事务状态为COMMIT_MESSAGE，则MessageSysFlag为TransactionCommitType；如果本地事务状态为ROLLBACK_MESSAGE，则MessageSysFlag为TransactionRollbackType。

   (2)调用this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,
                this.defaultMQProducer.getSendMsgTimeout()); RequestCode.END_TRANSACTION
                
         (1)根据commitLogOffset,直接从CommitLog中获取到上面的那条类型为`TransactionPreparedType`的消息(为了之后的说明，称为消息A)

         (2)构造一条和消息A一致的消息，称为消息B。

         (3)如果是TransactionRollbackType，则消息B的消息体为空。将消息B存入CommitLog，消息B不会存入Consume Queue中。

         (4)如果是TransactionCommitType,则消息B存入CommitLog和ConsumeQueue中。

在事务消息过程中，Broker 一共保存了两条消息。       

RocketMQ 这种实现事务方式,没有通过 KV 存储做,而是通过 Offset 方式,存在一个显著缺陷,即通过 Offset 更改数据,会令系统的脏页过多,需要特别关注。

参考：

![RocketMQ学习（八）：事务消息](http://lifestack.cn/archives/429.html)
