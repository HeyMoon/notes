TCP提供可靠的传输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能丢失。TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，她就重传该数据。对任何实现而言，关键之处就在于超时和重传的策略，即怎样决定超时间隔和如何确定重传的频率。

对于每一个TCP连接，TCP管理4个不同的定时器：

1. 重传定时器使用于当希望收到另一端的确认。

2. 坚持(persist)定时器是窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。

3. 保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启。

4. 2MSL定时器测量一个连接处于TIME_WAIT状态的时间。

重传时间差：

慢启动：连接上最初只允许传输一个报文段，然后在发送下一个报文段之前必须等待接收它的确认。当报文段被接收后，就可以在发送两个报文段。

拥塞：


源 于 伯 克 利 的 T C P 实 现 对 收 到 的 重 复 A C K 进行计 数，当收到第 3个时，就假定一个报文段已经丢失并重传自那个序号起的一个报文段。这就是 J a c o b s o n 的快速重传算法，该算法通常与他的快速恢复算法一起配合使用。


拥塞避免算法：
拥塞避免算法和慢启动算法是两个目的不同，独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来做到这一点。在实际中，这两个算法通常在一起实现。

拥塞避免算法和慢启动算法需要对每一个连接维持两个变量：一个拥塞窗口cwnd和一个慢启动门限ssthresh。这样得到的算法的工作过程如下：

1.  对一个给定的连接，初始化 c w n d为 1 个报文段， s s t h re s h为 6 5 5 3 5 个字节。

2. T C P 输出例程的输出不能超过 c w n d和 接 收 方 通 告 窗 口 的 大 小 。 拥 塞 避 免 是 发 送 方 使 用 的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估 计，而后者则与接收方在该连接上的可用缓存大小有关。

3. 当 拥 塞 发 生 时 ( 超 时 或 收 到 重 复 确 认 )， s s t h re s h被设置为当前窗口大小的一半( c w n d 和接收方通告窗口大小的最小值，但最少为 2个报文段)。此外，如果是超时引起了拥塞，则 c w n d 被设置为 1 个 报 文 段 ( 这 就 是 慢 启 动 )。

4. 当新的数据被对方确认时，就增加 c w n d ， 但 增 加 的 方 法 依 赖 于 我 们 是 否 正 在 进 行 慢 启 动或拥塞避免。如果 c w n d小于或等于 s s t h re s h， 则 正 在 进 行 慢 启 动 ， 否 则 正 在 进 行 拥 塞 避 免 。 慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止(因为我们记录了在步骤 2 中给我们制造麻烦的窗口大小的一半)，然后转为执行拥塞避免。

慢 启 动 算 法 初 始 设 置 c w n d 为 1 个 报 文 段 ， 此 后 每 收 到 一 个 确 认 就 加 1 。这会使窗口按指数方式增长:发送 1个报文段，然后是 2个，接着是 4个⋯⋯。

拥 塞 避 免 算 法 要 求 每 次 收 到 一 个 确 认 时 将 c w n d 增加 1 / c w n d 。 与 慢 启 动 的 指 数 增 加 比 起 来 ，
这 是 一 种 加 性 增 长 ( a d d i t i v e i n c r e a s e ) 。 我 们 希 望 在 一 个 往 返 时 间 内 最 多 为 c w n d 增加 1 个报文段 ( 不 管 在 这 个 R T T 中 收 到 了 多 少 个 A C K )， 然 而 慢 启 动 将 根 据 这 个 往 返 时 间 中 所 收 到 的 确 认 的
个数增加 c w n d 。

快速重传和快速恢复算法：

我们认识到在收到一个失序的报文段时， T C P 立即需要产生一个 A C K
( 一 个 重 复 的 A C K )。 这 个 重 复 的 A C K 不 应 该 被 迟 延 。 该 重 复 的 A C K 的 目 的 在 于 让 对 方 知 道 收 到一个失序的报文段，并告诉对方自己希望收到的序号。
由于我们不知道一个重复的 A C K是 由 一 个 丢 失 的 报 文 段 引 起 的 ， 还 是 由 于 仅 仅 出 现 了 几 个报文段的重新排序，因此我们等待少量重复的 A C K到 来 。 假 如 这 只 是 一 些 报 文 段 的 重 新 排 序 ， 则 在 重 新 排 序 的 报 文 段 被 处 理 并 产 生 一 个 新 的 A C K 之 前 ， 只 可 能 产 生 1 ~ 2 个重复的 A C K 。 如果一连串收到 3个或 3 个以上的重复 A C K ，就非常可能是一个报文段丢失了(我们在 2 1 . 5节 中见到过这种现象)。于是我们就重传丢失的数据报文段，而无需等待超时定时器溢出。这就 是快速重传算法。接下来执行的不是慢启动算法而是拥塞避免算法。这就是快速恢复算法。
