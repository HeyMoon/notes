1. 在开户中，我们可能要执行多个步骤，比如，开客户，开账户，开账户风控，新增密码等。在服务化架构中，这些步骤通常都是在不同的模块中，这意味着要和不同的模块交流。同时，各个步骤也有可能失败，那么如果失败了客户可能看到不完整的数据。在公共业务服务的实现中，在执行所有步骤之前都会记录各个步骤的状态。比如刚开始新建任务时，状态时初始化。在执行每一个步骤时，将对应步骤更改为处理中，步骤成功的话，状态改为成功，步骤失败的话，状态改为失败。如果有步骤失败的话，客户可能看到不完整的数据。在公共业务服务中，提供了一个"重试"的功能，即从失败的步骤开始重新进行之后的步骤。但是“重试”是一个运营人员触发的动作，这将导致不完整的数据出现的时间过长。那么，如何减少不完整的数据出现的时间呢？

+ 在对应步骤的接口中，配置重试机制，比如3次。这样可以提高成功率。
+ 每个步骤失败后，都自动触发“重试”功能而不是由运营人员抖动触发。

2. 一个很简单的任务：从文件服务器上下载文件，解析，然后处理。这个服务之前是只部署在一台服务器上的，现在如果要部署在多台服务器上，该如何改造？

+ 其实这是一个协调的过程。关键是如何协调多台服务器对同一个文件的访问。可以考虑分布式锁。比如可以用Zookeeper实现。在下载文件之前现在Zookeeper中建立一个Znode(znode 的名字可以为文件路径)，如果对应znode的存在，则不下载。否则，则开始下载，解析，处理（和单机一样）。但是这无法利用多机的服务。

+ 通过分析我们知道，下载和解析阶段是单线程处理。但是在处理阶段完全可以多线程处理的。所以我们可以把下载解析和处理分为两个服务，下载解析之间还是通过分布式锁协同。下载解析完成之后，将任务放入消息队列，处理服务从消息队列中取出任务处理。这样处理阶段就可以利用多个机器了。

3. 使用RabbitMQ如何实现顺序消息，并且支持集群特性？
+ 每一类需要保持顺序的消息发送到一个特定的序列，消费者组成一个Paxos/Raft集群
