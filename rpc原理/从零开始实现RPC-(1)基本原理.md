在实际开发中，我们免不了要依赖别人的服务或者我们想通过扩展机器集群来提高应用的吞吐量。可以借助RPC完成机器之间的调用。

1984 年，Birrell和Nelson设计了一种机制，[论文在此 ](http://www.cs.virginia.edu/~zaher/classes/CS656/birrel.pdf)。这种机制允许程序调用其他机器上的程序。比如，机器A上的一个进程可以调用机器B上的一个程序。**当调用发生时，机器A上的这个进程挂起(suspended)，机器B上的程序执行。当B返回时，返回值传递给A，然后A继续执行**。这种机制称为**Remote Procedure Call(RPC，远程过程调用)**。对于程序员来说，它就像一个普通的过程调用一样。显然，一个远程过程调用在底层实现上与本地过程调用不同。

## 远程过程调用的过程
我们先搞清楚本地过程调用是如何实现的。这因编译器和架构的不同而不同，所以我们概括来说。每一个处理器提供了一些`call`指令给我们，它将下一条指令的地址入栈(push)，将控制权转让给这个调用(call)指定的地址。当这个调用过程完成时，它发起一个`return`指令，从栈顶弹出(pop)地址，转让控制权。这是一个使得实现过程调用容易的基本的处理器机制。一些具体的细节取决于处理器。

调用远程机器上的过程时，这些都是没用的。这意味着，编译器要做一些不同的事来提供正在调用远程过程的假象。这使得RPC是一个语言级的构想，相反的，Sockets是操作系统级的构想。我们要通过本地过程调用和sockets来模拟远程过程调用。

使得远程过程调用可行的绝妙的技巧在于创建`stub functions`，它使得对于用户调用是本地的。**在client，一个stub 函数看起来就像用户打算调用的方法但是实际上包含了通过网络发送和接收报文的代码**。操作的顺序如下图所示：

![一次RPC的步骤](./rpc-flow.png)

1. 客户端调用一个名叫`client stub`的本地过程。对于客户端进程来说，这似乎是真实的过程，因为它是一个普通本地过程。有一点不同的是，实际的过程是在服务端。client stub将传递给远程过程的参数打包（可能需要转化为一个标准的格式，也就是通讯协议），组成一个或多个网络报文。打包的参数转化成网络报文称为`marshaling`，需要序列化所有的数据为byte。
2. client stub将网络报文发送给server（通过一次本地内核的系统调用，使用sockets API）。
3. server端的内核通过某些协议（无连接或者面向连接）接收到网络报文。
4. server stub，有时也叫`skeleton`，接收到报文。它从报文中`unmarshals`出调用参数。
5. server stub根据从客户端接收到的调用参数，调用相应的服务的方法。
6. 当服务端方法调用完毕，将返回值返回给server stub。
7. server stub转换返回值，`marshaling`它们为一个或多个网络报文，发送给client stub。
8. 报文通过网络传递回client stub。
9. client stub从本地内核中读取报文。
10. client stub将报文解码，返回结果给客户端方法。

## 实现远程过程调用
当我们想实现远程过程调用时，几个问题出现了。
### 1.如何伪装远程过程调用为透明？
我们想调用远程过程就像调用本地过程一样。文章开头就说了：使得远程过程调用可行的绝妙的技巧在于创建`stub functions`，它使得对于用户调用是本地的。**在client，一个stub 函数看起来就像用户打算调用的方法但是实际上包含了通过网络发送和接收报文的代码**。

### 2.如何传递参数？
通过值传递很简单：将值拷贝到网络报文就可以了。通过引用传递很困难。传递一个地址给远程机器是没有意义的，因为内存位置好像指向了与远程机器完全不同的地方。如果你想支持通过引用传递，你将要发送一份参数的拷贝，将它们放入远程系统的内存中，传递一个指向这些参数的指针给服务端方法，然后从引用拷贝对象，发送回client。如果远程过程调用支持复杂结构的引用，比如，tree和linked list，你将要拷贝这个结构为一个无指针的表示，传输，然后在服务端再次构造为这个数据结构。

### 3.如何表示数据？
在本地系统，没有数据不一致的问题。数据格式总是相同的。有了RPC，一个远程机器可能有不同的字节顺序(byte ordering)，不同大小的整数，不同的浮点数表示。这个问题在IP协议族中解决了，通过强迫每个人使用big-endian字节顺序表示头部中的16和32 bit字段。对于RPC，如果我们想和各种各样的系统交流，我们需要提出一个对所有的可以传递为参数的数据类型编码的标准编码方案。例如，ONC RPC，使用一个叫做XDR(eXternal Data Representation)的格式。这些数据表示格式可以使用隐式或显式类型。对于隐式类型，只有值会传递，变量的名字和类型不会传递。ONC RPC的XDR和DCE RPC的NDR是使用隐式类型的例子。对于显式类型，每个字段的类型和值都会传递，ISO 标准的ASN.1(Abstract Syntax Notation),JSON ,Google Protocol Buffers,和各种各样的基于XML的数据表示格式都是使用显式类型。

### 4.我们要连接到哪个机器和端口？
我们需要定位远程主机，和那个远程主机上的合适的进程（端口）。一个解决方法是维护一个集中的数据库，它可以定位提供一类服务的主机。a server发送信息到注册中心，注册它想提供的服务。a client当需要定为服务时，连接到注册中心，查询服务地址。当然也有一种不太优雅的方法：在client端硬编码服务连接地址。但是当服务不可用时或服务提供方有多个时，这显然不合适。

### 5.我们要使用哪种传输协议？
有些实现只允许使用一种（比如，TCP）。大多数实现提供了多种，允许用户选择。

### 6.出错时怎么办？
有很多情况会导致出错。server可能发生异常，网络的可能有问题，server可能宕机了，server在执行调用但是client却消失了。远程过程调用的透明性在这里打破了，因为本地过程调用没有过程调用失败的概念。因为这，使用远程过程调用的程序要准备好要么测试一个远程过程调用是否失败，要么捕捉异常。

### 7.远程调用的语义是什么？
调用一个普通过程的语义是很简单的：当调用时，一个过程只执行一次。对于一个远程过程，`只执行一次`很难实现。一个远程过程调用可能执行：

+ 零次，如果server宕机或在调用服务之前，服务已经死了。
+ 一次，如果每一个过程都运行良好。
+ 一次或大于一次，如果在返回server stub之后，发送响应之前，server宕机了。client将不能收到响应，决定再次调用，远程过程将被再次调用。如果client没有再次调用，远程过程只执行一次。
+ 大于一次，如果client超时并且重新传输。

RPC 系统通常会提供要么`至少一次`或`最多一次`的语义。我们需要了解系统的特性和远程过程的功能来决定调用一个方法多次是否是安全的。

### 8.如何实现同步或异步的调用
文章的开头已经提到：当调用发生时，机器A上的这个进程挂起(suspended)，机器B上的程序执行。当B返回时，返回值传递给A，然后A继续执行。这是Birrell和Nelson在论文中提出的。实际上，现在支持多种调用方式：one way，two way(同步),two way(异步)。

    one way实现起来比较简单，只需client端的进程/线程调用远程过程之后，直接返回。

    two way（同步），client端的进程/线程调用远程过程之后，挂起自己，等server端处理结果返回之后再唤醒，取出处理结果，继续执行。那么这里就有一个问题了，sever端的处理结果返回后，它怎么知道该唤醒哪个线程呢？所以我们需要一个为每一个调用线程生成一个唯一的key称为“requestId”，client在调用远程过程时，requestId和执行线程放入一个HashMap，调用时将requestId传给server，处理结果返回后，根据requestId从HashMap中取出线程，唤醒。

    two way(异步)，client在调用远程过程时，requestId放入一个Future中，client端继续执行，之后从Future中取出server处理结果。

### 9.性能？
一个普通过程调用是很快的：一般只是几个指令周期。远程过程调用呢？我们需要编码参数，调用操作系统里的网络模块（导致模式切换和上下文切换），处理网络延迟，让server接收到报文，传递报文给Server进程，解码参数，调用server 方法，在返回给client时，又整个做一次。毫无疑问，远程过程调用是很慢的。

### 10.安全？
+ client 发送报文给正确的远程进程了吗，或者这个进程是假冒的？
+ client 发送报文给正确的远程主机了吗，或者这个主机是假冒的？
+ server 只接收来自合法client的报文吗？server可以识别clien端的用户吗？
+ 当报文在网络中传输时，它可能被其它进程嗅探到吗？
+ 当报文在网络中传输时，它可能被其它进程翻译和修改吗？
+ 协议受重放攻击（replay attact）的影响吗？

参考：

[Remote Procedure Calls](https://www.cs.rutgers.edu/~pxk/417/notes/03-rpc.html)

[implementing Remote Procedure Calls](http://www.cs.virginia.edu/~zaher/classes/CS656/birrel.pdf)
