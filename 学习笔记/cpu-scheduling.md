---
title: cpu_scheduling
date: 2016-05-09 14:11:46
categories: 技术
tags: CPU调度
---
用户级线程调度是应用程序自己的事，与操作系统无关。在纯用户级多线程系统中，调度的对象依然是进程；而在内核级多线程和混合式策略中，调度的对象是内核级线程。
## CPU-I/O区间周期
CPU的成功调度依赖于进程的如下属性：进程执行由CPU执行和I/O等待周期(cycle)组成。进程在这两个状态之间切换。进程执行从CPU区间（CPU brust）开始，在这之后是I/O区间（I/0 brust），接着是另一个CPU区间，然后是另一个I/O区间，如此进行下去。最终，最后的CPU区间通过系统请求终止执行（图5.1）。
这些CPU区间的长度已被大量地测试过，虽然随着进程和计算机的不同变化很大，但是都呈现出类似于图5.2所示的频率曲线。该曲线通常为指数或超指数形式，具有**大量短CPU区间和少量长CPU区间**.I/O约束程序通常具有很多段CPU区间。CPU约束程序可能有少量的长CPU区间。这种分布有助于选择合适的CPU调度算法。

<img src="./Snip20160510_3.png">

## CPU调度程序
CPU调度决策可在如下四种环境下发生：

+ 当一个进程从运行状态切换到等待状态(例如，I/O请求的结果，或调用wait等待一个子进程的终止)。
+ 当一个进程从运行状态切换到就绪状态（例如，出现中断）
+ 当一个进程从等待状态切换到就绪状态（例如，I/O完成）
+ 当一个进程终止时

对于第一和第四种情况，没有选择而只有调度。

当调度只能发生在第一和第四两种情况下时，称调度方案是非抢占的(nonpreemptive)或协作(cooperative)；否则，称调度方案是抢占的（preemptive）。

采用非抢占调度，一旦CPU分配给一个进程，那么该进程就会一直使用CPU，直到进程终止或切换到等待状态。

不幸的是，抢占调度对访问共享数据是有代价的。考虑两个进程共享数据的情况。第一个进程正在更新数据时，它被抢占以使第二个进程能够运行。第二个进程可能试图读数据，该数据现在处于不一致的状态。这种情况下需要一种新机制来协调对共享数据的访问。

抢占对操作系统内核的设计也有影响。在处理系统调用时，内核可能忙于进程活动。这些活动可能涉及要改变的重要内核数据(如I/O队列)。如果一个进程正在进行这些修改时被抢占，以及内核（或设备驱动程序）需要读取或修改同样的结构，那么会有什么结果呢？肯定会导致混乱。有的操作系统，包括绝大多数UNIX系统，通过在上下文切换之前等待系统调用完成或等待发生I/O阻塞来处理这一个问题。这种机制确保内核结构的简单性，因为当内核数据结构处于不一致状态时，内核不会抢占进程。但，这种内核执行模式对实时计算和多进程的支持较差。

CPU调度程序担负两项任务：调度和分派。前者实现调度策略(scheduling policy)，确定就绪态进程/线程竞争使用处理器的次序的裁决原则，即进程/线程何时应放弃CPU和选择哪个进程/线程来执行；后者实现调度机制(scheduling mechanism)，确定如何时分复用CPU，处理上下文交换细节，完成进程/线程通CPU的绑定及放弃的实际工作。

从概念上来看，调度机制由3个逻辑功能程序模块组成：

1. 队列管理程序<br/>
就绪队列不必是先进先出队列。就绪队列可实现为FIFO队列，优先队列，树或者简单的无序链表。
当一个进程/线程转换为就绪态时，其PCB/TCB就会被更新以反映这种变化，队列管理程序将PCB/TCB指针放入等待CPU资源的进程/线程列表中，每当把进程/线程移入就绪队列时，可计算为此进程/线程分配CPU的优先级备用。
2. 上下文切换程序<br/>
当调度程序把CPU从正在运行的进程/线程那里切换至另一个进程/线程时，上下文切换程序将当前运行进程/线程的上下文信息保存至其PCB/TCB中，恢复选中进程/线程的上下文信息，从而使其占有处理器运行。

3. 分派程序<br/>
分派程序用来将CPU的控制权交给选择地进程，其功能包括：
+ 切换上下文
+ 切换到用户模式
+ 跳转到用户程序的合适位置，以重新启动程序。

分派程序应尽可能快，因为每次进程切换时都要使用。分配程序停止一个进程而启动另一个所要花的时间成为分派延迟。

## 调度准则
不同的CPU调度算法具有不同属性，且可能对某些进程更为有利。为了选择算法以适合特定情况，必须分析各个算法的特点。

为了比较CPU调度算法，准则如下：

+ CPU使用率。需要使CPU尽可能的忙。
+ 吞吐量(throughput)。如果CPU忙于执行进程，那么就有工作在完成。一种测量工作量的方法称为吞吐量，它指一个时间单位内所要完成进程的数量。对于短进程，吞吐量可能为每秒10个进程。
+ 周转时间（turnaround time）。从一个特定进程的角度来看，一个重要的准则是运行该进程需要多长时间。从进程提交到进程完成的时间称为周转时间。周转时间为所有时间段之和，包括等待进入内存，在就绪队列中等待，在CPU上执行和I/O执行。
+ 等待时间。CPU调度算法并不影响进程运行和执行I/O的时间：它只影响进程在就绪队列中等待所花的时间。
+ 响应时间。

要使CPU使用率和吞吐量最大化，而使周转时间，等待时间和响应时间最小化。在绝大多数情况下，需要优化平均值。


## 调度算法
### 先到先服务(first come,first served)
顾名思义，先请求CPU的进程先分配CPU。用FIFO队列可以很容易的实现FCFS策略。当一个进程进入到就绪队列，其PCB链接到队列的尾部。当CPU空闲时，CPU分配给位于队列头的进程。接着该运行进程从队列中删除。

不过采用FCFS策略的平均等待时间通常较长。

FCFS调度算法是非抢占的。一旦CPU被分配给了一个进程，该进程就会保持CPU直到释放CPU为止，即程序终止或是请求I/O。FCFS算法对于分时系统（每个用户需要定时地得到一定的CPU时间）是特别麻烦的。

### 最短作业优先调度（shortest-job-first scheduling）
这一算法将每个进程与其下一个CPU区间段相关联。当CPU空闲时，他就会赋给具有最短CPU区间的进程。如果两个进程具有同样长度，那么可以使用FCFS调度来处理。一个更为适当的表示是下一个最短CPU区间的算法，这是因为调度程序检查进程下一个CPU区间的长度，而不是其总长度。

SJF算法可证明为最优算法，这是因为对于给定的一组进程，SJF算法的平均等待时间最短。通过将短进程移到长进程之前，短进程等待时间的减少大于长进程等待时间的增加。因而，平均等待时间缩短了。

SJF算法的真正困难是如何知道下一个CPU区间的长度。

虽然SJF算法最优，但是它不能再短期CPU调度层次上加以实现，因为没有办法知道下一个CPU区间的长度。一种方法是近似SJF调度，虽然不知道下一个CPU区间的长度，但是可以预测它的值。认为下一个CPU区间的长度与以前的相似。

SJF算法可以是抢占的或非抢占的。当一个新进程到达就绪队列而以前进程正在执行时，就需要选择。与当前运行的进程相比，新进程可能有一个更短的CPU区间。抢占SJF算法可抢占当前运行的进程，而非抢占SJF算法会允许当前运行的进程先完成其CPU区间。

### 优先级调度
SJF算法可作为**通用优先级调度算法**（priority scheduling algorithm）的一个特例。每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU。具有相同优先级的进程按FCFS顺序调度。SJF算法属于简单优先级算法，其优先级为下一个（预测的）CPU区间的倒数。

优先级可通过内部或外部方式来定义。内部定义优先级使用一些测量数据以一算进程优先级。例如，时间极限，内存要求，打开文件数量和平均I/O区间与平均CPU区间之间都可以用于计算优先级。外部优先级通过操作系统之外的准则来定义。如进程重要性等。

优先级调度可以是抢占的或者非抢占的。当一个进程到达就绪队列时，其优先级与当前运行进程的优先级相比较。

优先级调度算法的一个主要问题是无穷阻塞(indefinite blocking)或饥饿(starvation)。优先级调度算法会使某个低优先级进程无穷等待CPU。

低优先级进程无穷等待问题的解决之一是老化(aging)。老化是一种技术，以逐渐增加在系统中等待很长时间的进程的优先级。

### 轮转调度(round-robin)
round-robin是专门为分时系统设计的。它类似与FCFS调度，但是增加了抢占以切换进程。定义一个较小的时间单元，称为时间片（time slice）。时间片通常为10~100ms。将就绪队列作为循环队列。CPU调度程序循环就绪队列，为每一个进程分配不超过一个时间片的CPU。

为了实现轮转调度，将就绪队列保存为进程的FIFO队列。新进程增加到就绪队列的尾部。CPU调度程序从就绪队列中选择第一个进程，设置定时器在一个时间片之后中断，再分派该进程。


接下来将可能发生两种情况之一。进程可能只需要小于时间片的CPU区间。对于这种情况，进程本身会自动释放CPU。调度程度接着处理就绪队列的下一个进程。否则，如果当前运行进程的CPU区间比时间片长，定时器会中断并产生操作系统中断，然后进行上下文切换，将进程加入到就绪队列的尾部，接着CPU调度程序会选择就绪队列中的下一个进程。

不过采用round-robin调度策略的平均等待时间通常较长。

轮转调度算法的性能很大程度上依赖与时间片的大小。在极端情况下，如果时间片非常大，那么轮转调度算法与FCFS算法一样。

如果使用软件。那么还必须考虑上下文切换对轮转调度的影响。假设只有一个需要10个时间单元的进程。如果时间片为12个时间单元，那么进程一个时间片不到就能完成，且没有额外开销。
如果时间片为6个时间单元，那么进程需要2个时间片，并产生了一个上下文切换。

因此，希望时间片要比上下文切换时间长。如果上下文切换时间约为时间片的10%，那么约有10%的CPU时间会浪费在上下文切换上。事实上，绝大多数现代操作系统的时间片尾10~100ms，上下文切换的时间一般少于10um。

### 多级队列调度
在进程可容易分成不同组的情况下，可以建立另一类调度算法。例如，一个常用的划分方法是前台(foreground)(交互)进程和后台(background)（批处理）进程。这两种不同类型的进程具有不同响应时间要求，也有不同调度需要。另外，与后台进程相比，前台进程要有更高的优先级。

多级队列调度算法(multilevel queue scheduling algorithm)将就绪队列分成多个独立队列。根据进程属性，如内存大小、进程优先级、进程类型，一个进程被永久地分配到一个队列。每个队列都有自己的调度算法。

另外，队列之间必须要有调度，通常采用固定优先级抢占调度。例如，前台队列可以比后台队列具有绝对的优先级。

### 多级反馈队列调度
通常在使用多级队列调度算法时，进程进入系统时被永久地分配到一个队列。例如，如果前台进程和后台进程分别有独立队列，进程并不从一个队列转移到另一个队列。这种设置的优点是调度开销低，缺点是不够灵活。

与之相反，多级反馈队列调度算法(multilevel feedback queue scheduling algorithm)允许进程在队列之间移动。其主要思想是根据不同CPU区间的特点以区分进程。如果进程使用过多CPU时间，那么它会被转移到更低优先级队列。这种方案将I/O约束和交互进程留在更高优先级队列。此外，在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止饥饿的发生。

通常，多级反馈队列调度程序可由下列参数来定义：

+ 队列数量
+ 每个队列的调度算法
+ 用以确定何时升级到更高优先级队列的方法
+ 用以确定何时降级到更低优先级队列的方法
+ 用以确定进程在需要服务时应进入哪个队列的方法

多级反馈队列调度程序的定义使它成为最通用的CPU调度算法。


## 多处理器调度
以上主要讨论了单处理器系统内的CPU调度问题。如果有多个CPU，则负载分配(load sharing)成为可能。
下面简要讨论多处理器调度相关问题，其中主要讨论







 